//------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------


#include <cmath>
#include <memory>

//------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------

#include "Transform.h"

//------------------------------------------------------------------------------------------------------
//------------------------------------------------------------------------------------------------------

namespace GDX
{
    const Transform Transform::IDENTITY = Transform();

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform::Transform()
    {
        Identity();
    }

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform::Transform(const Transform &transform)
    {
        memcpy(m_values[0], transform.m_values[0], sizeof(float) * 3);
        memcpy(m_values[1], transform.m_values[1], sizeof(float) * 3);
    }

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform::Transform(const float row00,
						const float row01,
						const float row02,
						const float row10,
						const float row11,
						const float row12)
	{
		m_values[0][0] = row00;
		m_values[0][1] = row01;
		m_values[0][2] = row02;

		m_values[1][0] = row10;
		m_values[1][1] = row11;
		m_values[1][2] = row12;
	}

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform &Transform::Identity()
	{
		m_values[0][0] = 1;
		m_values[0][1] = 0;
		m_values[0][2] = 0;

		m_values[1][0] = 0;
		m_values[1][1] = 1;
		m_values[1][2] = 0;

		return *this;
	}

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform& Transform::Scale(const float scaleUniform)
	{
		return Scale(scaleUniform, scaleUniform);
	}

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform& Transform::Scale(const float scaleX, const float scaleY)
	{
		m_row0[0] *= scaleX;
		m_row0[1] *= scaleY;
		m_row1[0] *= scaleX;
		m_row1[1] *= scaleY;

		return *this;
	}

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform& Transform::Translate(const Vector& v)
	{
		return Translate(v.m_x, v.m_y);
	}

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform& Transform::Translate(const float x, const float y)
	{
		m_translateX += m_row0[0] * x + m_row0[1] * y;
		m_translateY += m_row1[0] * x + m_row1[1] * y;

		return *this;
	}

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform& Transform::Rotate(const float radians)
	{
		const float c = cos(radians);
		const float s = sin(radians);

		const float original[2][2] = {m_row0[0], m_row1[0], m_row0[1], m_row1[1]};

		m_row0[0] = original[0][0] * c - original[0][1] * s;
		m_row0[1] = original[0][0] * s + original[0][1] * c;
		m_row1[0] = original[1][0] * c - original[1][1] * s;
		m_row1[1] = original[1][0] * s + original[1][1] * c;

		return *this;
	}

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Transform Transform::operator*(const Transform& other) const
	{
		return Transform(
			m_values[0][0] * other.m_values[0][0] + m_values[0][1] * other.m_values[1][0],
			m_values[0][0] * other.m_values[0][1] + m_values[0][1] * other.m_values[1][1],
			m_values[0][0] * other.m_values[0][2] + m_values[0][1] * other.m_values[1][2] + m_values[0][2],
			m_values[1][0] * other.m_values[0][0] + m_values[1][1] * other.m_values[1][0],
			m_values[1][0] * other.m_values[0][1] + m_values[1][1] * other.m_values[1][1],
			m_values[1][0] * other.m_values[0][2] + m_values[1][1] * other.m_values[1][2] + m_values[1][2]);
	}

	//------------------------------------------------------------------------------------------------------
	//------------------------------------------------------------------------------------------------------

	Vector Transform::operator*(const Vector& vector) const
	{
		return Vector(
			m_row0[0] * vector.m_x + m_row0[1] * vector.m_y + m_translateX,
			m_row1[0] * vector.m_x + m_row1[1] * vector.m_y + m_translateY);
	}
}